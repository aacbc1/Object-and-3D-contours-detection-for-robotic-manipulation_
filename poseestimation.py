# -*- coding: utf-8 -*-
"""PoseEstimation.ipynb

Automatically generated by Colab.



import numpy as np
import matplotlib.pyplot as plt
import cv2

w, h, d = 9 / 2, 14 / 2, 4 / 2

ply_content = f"""
ply
format ascii 1.0
element vertex 8
property float x
property float y
property float z
element face 12
property list uchar int vertex_index
end_header
{-w} {-h} {-d}
{w} {-h} {-d}
{w} {h} {-d}
{-w} {h} {-d}
{-w} {-h} {d}
{w} {-h} {d}
{w} {h} {d}
{-w} {h} {d}
3 0 1 2
3 2 3 0
3 4 5 6
3 6 7 4
3 0 4 5
3 5 1 0
3 1 5 6
3 6 2 1
3 2 6 7
3 7 3 2
3 3 7 4
3 4 0 3
"""

with open("kakao.ply", "w") as f:
    f.write(ply_content.strip())

def showEdges(img):
  plt.figure(figsize=(6, 8))
  plt.imshow(img)
  plt.title("Edges")
  plt.axis("off")
  plt.show()

w = 4.5
h = 10.5
d = 4.5
object_points = np.array([
    [-w/2, -h/2, -d/2],  # donji lijevi prednji
    [ w/2, -h/2, -d/2],  # donji desni prednji
    [ w/2,  h/2, -d/2],  # gornji desni prednji
    [-w/2,  h/2, -d/2],  # gornji lijevi prednji
    [-w/2, -h/2,  d/2],  # donji lijevi zadnji
    [ w/2, -h/2,  d/2],  # donji desni zadnji
    [ w/2,  h/2,  d/2],  # gornji desni zadnji
    [-w/2,  h/2,  d/2],  # gornji lijevi zadnji
], dtype=np.float32)

faces = {
    "back":  [0, 1, 2, 3],
    "front":  [4, 5, 6, 7],
    "left":   [0, 3, 7, 4],
    "right":  [1, 2, 6, 5],
    "top":    [3, 2, 6, 7],
    "bottom": [0, 1, 5, 4]
}

left_faces = {
    "front":   [4, 5, 6, 7],
    "left":   [0, 3, 7, 4]
}
front_faces = {
    "front":   [4, 5, 6, 7],

}
bottom_faces = {
    "front":   [4, 5, 6, 7],
    "bottom": [0, 1, 5, 4]
}
bottom_left_faces = {
    "front":   [4, 5, 6, 7],
    "left":   [0, 3, 7, 4],
    "bottom": [0, 1, 5, 4]
}
bottom_right_faces = {
    "front":   [4, 5, 6, 7],
    "right":  [1, 2, 6, 5],
    "bottom": [0, 1, 5, 4]
}
right_faces = {
    "front":   [4, 5, 6, 7],
     "right":  [1, 2, 6, 5],
}


bottom_left = sorted(list(set([
    4, 5,
    0, 1,
    3, 7
])))
bottom = sorted(list(set([
    4, 5,
    0, 1
])))
bottom_right = sorted(list(set([
    1, 2,
    4, 5,
    6, 0
])))
left = sorted(list(set([
    0, 3,
    4, 6,
    7, 5
])))
right = sorted(list(set([
    1, 2,
    5, 6,
    7, 5
])))

K = np.array([
    [3550,  0, 2016],
    [ 0, 3550, 1512],
    [ 0,  0,  1]
])

img1 = cv2.imread("img1.jpg")
img2 = cv2.imread("img2.jpg")
img3 = cv2.imread("img3.JPG")
img4 = cv2.imread("img4.JPG")
img5 = cv2.imread("img5.JPG")

import cv2
import numpy as np

img = cv2.imread("kakao1.jpg")


front_face = np.array([
    [-w/2, -h/2, d/2],
    [ w/2, -h/2, d/2],
    [ w/2,  h/2, d/2],
    [-w/2,  h/2, d/2],
], dtype=np.float32)

image_points1 = np.array([
    [1000, 3050],
    [2000, 3050],
    [2050, 1400],
    [1020, 1370],

], dtype=np.float32)

for pt in image_points1:
    cv2.circle(img, center=(int(pt[0]), int(pt[1])), radius=5, color=(0, 0, 255), thickness=-1)

img_rgb = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)

showEdges(img_rgb)

success, rvec1, tvec1 = cv2.solvePnP(
    front_face, image_points1, K, None,
    flags=cv2.SOLVEPNP_ITERATIVE
)
if success:
    print("R_vec1 =\n", rvec1)
    print("t_vec1 =\n", tvec1)
else:
    print("Unsuccessful")

right_face = np.array([
    [-w/2, -h/2, d/2],  # donji lijevi
    [ w/2, -h/2, d/2],  # donji desni
    [ w/2,  h/2, d/2],  # gornji desni
    [-w/2,  h/2, d/2],  # gornji lijevi
    [ w/2, -h/2,  d/2],  # donji desni zadnji
    [ w/2,  h/2,  d/2],  # gornji desni zadnji

], dtype=np.float32)

image_points2 = np.array([
    [650, 2600],
    [1550, 2650],
    [1820, 930],
    [970, 1070],
    [1800, 2750],
    [2030, 1190],
], dtype=np.float32)


for pt in image_points2:
    cv2.circle(img2, center=(int(pt[0]), int(pt[1])), radius=5, color=(0, 0, 255), thickness=-1)

img_rgb2= cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)

showEdges(img_rgb2)


success, rvec2, tvec2 = cv2.solvePnP(
    right_face, image_points2, K, None,
    flags=cv2.SOLVEPNP_ITERATIVE
)
if success:
    print("R_vec2 =\n", rvec2)
    print("t_vec2 =\n", tvec2)
else:
    print("Unsuccessful")

object_points_left =  np.array([
    np.array([
    [-w/2, -h/2, d/2],  # donji lijevi
    [ w/2, -h/2, d/2],  # donji desni
    [ w/2,  h/2, d/2],  # gornji desni
    [-w/2,  h/2, d/2],  # gornji lijevi
    [-w/2,  h/2, -d/2],
    [-w/2,  -h/2, -d/2],
], dtype=np.float32)
])

image_points3 = np.array([
    [1250, 2750],
    [2450, 2950],
    [2570, 1150],
    [1560,730],
    [1300, 1000],
    [1000,2800],

], dtype=np.float32)
for pt in image_points3:
    cv2.circle(img3, center=(int(pt[0]), int(pt[1])), radius=5, color=(0, 0, 255), thickness=-1)

img_rgb3= cv2.cvtColor(img3, cv2.COLOR_BGR2RGB)

showEdges(img_rgb3)


success, rvec3, tvec3 = cv2.solvePnP(
    object_points_left, image_points3, K, None,
    flags=cv2.SOLVEPNP_ITERATIVE
)
if success:
    print("R_vec3 =\n", rvec3)
    print("t_vec3 =\n", tvec3)
else:
    print("Unsuccessful")

image_points4 = np.array([
    [900, 2400],
    [2500,2430],
    [2250, 860],
    [1160,800],
    [950, 2750],
    [2320,2780],
], dtype=np.float32)

object_points_bottom = np.array([
    [-w/2, -h/2, d/2],
    [ w/2, -h/2, d/2],
    [ w/2,  h/2, d/2],
    [-w/2,  h/2, d/2],
    [-w/2, -h/2, -d/2],
    [ w/2, -h/2, -d/2],
], dtype=np.float32)

for pt in image_points4:
    cv2.circle(img4, center=(int(pt[0]), int(pt[1])), radius=5, color=(0, 0, 255), thickness=-1)

img_rgb4= cv2.cvtColor(img4, cv2.COLOR_BGR2RGB)

showEdges(img_rgb4)

success, rvec4, tvec4 = cv2.solvePnP(
    object_points_bottom, image_points4, K, None,
    flags=cv2.SOLVEPNP_ITERATIVE
)

if success:
    print("R_vec4 =\n", rvec4)
    print("t_vec4 =\n", tvec4)
else:
    print("Unsuccessful")

image_points5 = np.array([
    [1100, 3070],
    [2170,3070],
    [2250, 1320],
    [1250,1180],
    [1000, 2980],
    [1120,1370],
], dtype=np.float32)

for pt in image_points5:
    cv2.circle(img5, center=(int(pt[0]), int(pt[1])), radius=5, color=(0, 0, 255), thickness=-1)

img_rgb5= cv2.cvtColor(img5, cv2.COLOR_BGR2RGB)

showEdges(img_rgb5)

success, rvec5, tvec5 = cv2.solvePnP(
    object_points_left, image_points5, K, None,
    flags=cv2.SOLVEPNP_ITERATIVE
)
if success:
    print("R_vec5 =\n", rvec5)
    print("t_vec5 =\n", tvec5)
else:
    print("Unsuccessful")

sift = cv2.SIFT_create()

kp1, des1 = sift.detectAndCompute(img1, None)
kp2, des2 = sift.detectAndCompute(img2, None)
kp3, des3 = sift.detectAndCompute(img3, None)
kp4, des4 = sift.detectAndCompute(img4, None)
kp5, des5 = sift.detectAndCompute(img5, None)

from shapely.geometry import Polygon
from shapely.geometry import Point

def associate_sift_with_faces(img, kp, des, projected, faces_to_use, face_colors=None, draw=True):

    face_polygons = {}
    for name, indices in faces_to_use.items():
        pts = projected[indices]
        poly = Polygon(pts)
        face_polygons[name] = poly

    point_to_face = {}
    for idx, k in enumerate(kp):
        pt = Point(k.pt)
        assigned_face = None
        for face_name, poly in face_polygons.items():
            if poly.contains(pt):
                assigned_face = face_name
                break
        point_to_face[idx] = assigned_face

    descriptor_db = []
    for idx, face_name in point_to_face.items():
        if face_name is not None:
            descriptor_db.append((des[idx], face_name))

    if draw:
        if face_colors is None:
            face_colors = {
                "back":  (255, 0, 0),
                "front": (0, 255, 0),
                "left":  (0, 0, 255),
                "right": (255, 255, 0),
                "top":   (0, 255, 255),
                "bottom":(255, 0, 255)
            }

        img_vis = img.copy()
        for idx, k in enumerate(kp):
            face = point_to_face.get(idx, None)
            if face:
                color = face_colors.get(face, (255, 255, 255))
                x, y = int(k.pt[0]), int(k.pt[1])
                cv2.circle(img_vis, (x, y), 3, color, -1)

        plt.figure(figsize=(10, 10))
        plt.imshow(cv2.cvtColor(img_vis, cv2.COLOR_BGR2RGB))
        plt.title("SIFT points colored by side of the bounding box")
        plt.axis('off')
        plt.show()
    return descriptor_db

bottom_left = sorted(list(set([
    4, 5,
    0, 1,
    3, 7
])))
bottom = sorted(list(set([
    4, 5,
    0, 1
])))
bottom_right = sorted(list(set([
    1, 2,
    4, 5,
    6, 0
])))
left = sorted(list(set([
    0, 3,
    4, 6,
    7, 5
])))
right = sorted(list(set([
    1, 2,
    5, 6,
    7, 5
])))
front = sorted(list(set([
    1, 2,
    5, 6,
    7, 5
])))

projected, _ = cv2.projectPoints(object_points, rvec1, tvec1, K, None)
projected = projected.reshape(-1, 2).astype(int)
selected_indices = left

object_points_selected = object_points[selected_indices]
projected_selected = projected[selected_indices]

front_faces = {
    "front": faces["front"]
}
descriptor_database1 = associate_sift_with_faces(
    img=img1,
    kp=kp1,
    des=des1,
    projected=projected,
    faces_to_use=front_faces,
    draw=True
)

print(f"Number of descriptors on the sides of the bounding box: {len(descriptor_database1)}")

_projected, _ = cv2.projectPoints(object_points, rvec2, tvec2, K, None)
projected = projected.reshape(-1, 2).astype(int)
selected_indices = rig

object_points_selected = object_points[selected_indices]
projected_selected = projected[selected_indices]

right_face = {
    "front": faces["front"],
    "right": faces["right"]
}


descriptor_database2 = associate_sift_with_faces(
    img=img2,
    kp=kp2,
    des=des2,
    projected=projected,
    faces_to_use=right_face,
    draw=True
)

print(f"Number of descriptors on the sides of the bounding box: {len(descriptor_database2)}")

projected, _ = cv2.projectPoints(object_points, rvec3, tvec3, K, None)
projected = projected.reshape(-1, 2).astype(int)
selected_indices = bottom_left

object_points_selected = object_points[selected_indices]
projected_selected = projected[selected_indices]

bottom_left_faces = {
    "front": faces["front"],
    "left": faces["left"]
}

descriptor_database3 = associate_sift_with_faces(
    img=img3,
    kp=kp3,
    des=des3,
    projected=projected,
    faces_to_use=bottom_left_faces,
    draw=True
)

print(f"Number of descriptors on the sides of the bounding box: {len(descriptor_database3)}")

projected, _ = cv2.projectPoints(object_points, rvec4, tvec4, K, None)
projected = projected.reshape(-1, 2).astype(int)
selected_indices = bottom

object_points_selected = object_points[selected_indices]
projected_selected = projected[selected_indices]

bottom_faces = {
    "bottom": faces["bottom"],
    "front": faces["front"]
}



descriptor_database4 = associate_sift_with_faces(
    img=img4,
    kp=kp4,
    des=des4,
    projected=projected,
    faces_to_use=bottom_faces,
    draw=True
)

print(f"Number of descriptors on the sides of the bounding box: {len(descriptor_database4)}")

projected, _ = cv2.projectPoints(object_points, rvec5, tvec5, K, None)
projected = projected.reshape(-1, 2).astype(int)
selected_indices = left

object_points_selected = object_points[selected_indices]
projected_selected = projected[selected_indices]


descriptor_database5 = associate_sift_with_faces(
    img=img5,
    kp=kp5,
    des=des5,
    projected=projected,
    faces_to_use=left_faces,
    draw=True
)

print(f"Number of descriptors on the sides of the bounding box: {len(descriptor_database5)}")

global_descriptor_database = []
list_of_data = [
    (img, kp1, des1, rvec1, tvec1, front_faces),
    (img2, kp2, des2, rvec2, tvec2, right_faces),
    (img3, kp3, des3, rvec3, tvec3, left_faces),
    (img4, kp4, des4, rvec4, tvec4, bottom_faces),
    (img5, kp5, des5, rvec5, tvec5, left_faces)

]

for (img_i, kp_i, des_i, rvec_i, tvec_i, faces_to_use_i) in list_of_data:
    projected_i, _ = cv2.projectPoints(object_points, rvec_i, tvec_i, K, None)
    projected_i = projected_i.reshape(-1, 2).astype(int)

    descriptor_db_i = associate_sift_with_faces(
        img=img_i,
        kp=kp_i,
        des=des_i,
        projected=projected_i,
        faces_to_use=faces_to_use_i,
        draw=False
    )
    global_descriptor_database.extend(descriptor_db_i)

keypoints_list = [kp1, kp2, kp3,kp4,kp5]
descriptors_list = [des1, des2, des3,des4,des5 ]

def load_ply_mesh(ply_path):
    with open(ply_path, 'r') as f:
        lines = f.readlines()

    vertex_count = 0
    face_count = 0
    header_ended = False
    vertices = []
    triangles = []

    for i, line in enumerate(lines):
        if line.startswith("element vertex"):
            vertex_count = int(line.split()[-1])
        elif line.startswith("element face"):
            face_count = int(line.split()[-1])
        elif line.strip() == "end_header":
            header_ended = True
            header_end_idx = i
            break

    for line in lines[header_end_idx+1 : header_end_idx+1+vertex_count]:
        x, y, z = map(float, line.strip().split()[:3])
        vertices.append([x, y, z])

    for line in lines[header_end_idx+1+vertex_count : header_end_idx+1+vertex_count+face_count]:
        parts = line.strip().split()
        if int(parts[0]) != 3:
            continue  # skip non-triangle
        idx = list(map(int, parts[1:4]))
        triangles.append(idx)

    vertices = np.array(vertices, dtype=np.float32)
    return vertices, triangles
vertices, triangles = load_ply_mesh("kakao.ply")

def backproject2DPoint(pt2d, K, R, t, vertices, triangles):

    pt2d_hom = np.array([pt2d[0], pt2d[1], 1.0], dtype=np.float32)
    ray_dir_cam = np.linalg.inv(K).dot(pt2d_hom)
    ray_dir_cam = ray_dir_cam / np.linalg.norm(ray_dir_cam)

    ray_origin_world = np.zeros(3)
    ray_dir_world = ray_dir_cam

    ray_origin_world = R.T @ (ray_origin_world - t.reshape(3,))
    ray_dir_world = R.T @ ray_dir_world
    ray_dir_world = ray_dir_world / np.linalg.norm(ray_dir_world)

    min_t = float('inf')
    hit_point = None

    for tri_indices in triangles:
        v0 = vertices[tri_indices[0]]
        v1 = vertices[tri_indices[1]]
        v2 = vertices[tri_indices[2]]

        hit, t_val = intersect_moller_trumbore(ray_origin_world, ray_dir_world, v0, v1, v2)
        if hit and t_val < min_t:
            min_t = t_val
            hit_point = ray_origin_world + t_val * ray_dir_world

    if hit_point is not None:
        return True, hit_point
    else:
        return False, None



def intersect_moller_trumbore(orig, dir, v0, v1, v2, epsilon=1e-3):
    orig = np.asarray(orig).reshape(3,)
    dir = np.asarray(dir).reshape(3,)
    v0 = np.asarray(v0).reshape(3,)
    v1 = np.asarray(v1).reshape(3,)
    v2 = np.asarray(v2).reshape(3,)

    edge1 = v1 - v0
    edge2 = v2 - v0
    h = np.cross(dir, edge2)
    a = np.dot(edge1, h)

    if abs(a) < epsilon:
        return False, None

    f = 1.0 / a
    s = orig - v0
    u = f * np.dot(s, h)

    if u < 0.0 or u > 1.0:
        return False, None

    q = np.cross(s, edge1)
    v = f * np.dot(dir, q)

    if v < 0.0 or u + v > 1.0:
        return False, None

    t = f * np.dot(edge2, q)
    if t > epsilon:
        return True, t
    else:
        return False, None

def backproject_keypoints_to_mesh(keypoints, K, R, t, vertices, triangles):
    points_3d = []

    for kp in keypoints:
        pt2d = kp.pt  # (x, y)
        hit, point3d = backproject2DPoint(pt2d, K, R, t, vertices, triangles)
        if hit:
            points_3d.append(point3d)
        else:

            points_3d.append(None)

    return points_3d

model_keypoints = []
model_descriptors = []
model_2dpoints_in = []
model_2dpoints_out = []
model_3dpoints = []

def register_model(img_in, keypoints, descriptors, K, R, t, vertices, triangles):
    for i, kp in enumerate(keypoints):
        pt2d = kp.pt
        ok, pt3d = backproject2DPoint(pt2d, K, R, t, vertices, triangles)
        if ok and descriptors[i] is not None:
            model_keypoints.append(kp)
            model_descriptors.append(descriptors[i])
            model_2dpoints_in.append(pt2d)
            model_3dpoints.append(pt3d)
        else:
            model_2dpoints_out.append(pt2d)

    print(f"Inliers: {len(model_2dpoints_in)}")
    print(f"Outliers: {len(model_2dpoints_out)}")

    img_vis = img_in.copy()

    for pt in model_2dpoints_in:
        cv2.circle(img_vis, (int(pt[0]), int(pt[1])), 3, (0, 255, 0), -1)
    for pt in model_2dpoints_out:
        cv2.circle(img_vis, (int(pt[0]), int(pt[1])), 3, (0, 0, 255), -1)

    cv2.putText(img_vis, f"Inliers: {len(model_2dpoints_in)}", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
    cv2.putText(img_vis, f"Outliers: {len(model_2dpoints_out)}", (10, 70), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)

    plt.figure(figsize=(10, 10))
    plt.imshow(cv2.cvtColor(img_vis, cv2.COLOR_BGR2RGB))
    plt.title("MODEL REGISTRATION")
    plt.axis('off')
    plt.show()

    return {
        "keypoints": model_keypoints,
        "descriptors": np.array(model_descriptors),
        "points2d_in": model_2dpoints_in,
        "points3d": model_3dpoints
    }

i = 0
keypoints_list = [kp1,kp2,kp3,kp4,kp5]
descriptors_list = [des1,des2,des3,des4,des5]
kp = keypoints_list[i]
des = descriptors_list[i]
rvec = rvec5
tvec = tvec5
R, _ = cv2.Rodrigues(rvec)
model_keypoints = []
model_descriptors = []
model_2dpoints_in = []
model_2dpoints_out = []
model_3dpoints = []
result = register_model(img5, kp5, des5, K, R, tvec, vertices, triangles)

import random
import cv2
import matplotlib.pyplot as plt

img = cv2.imread("img1.JPG")
img_test = img.copy()
h_img, w_img = img.shape[:2]

for i in range(20):
    x_rand = random.randint(0, w_img - 1)
    y_rand = random.randint(0, h_img - 1)
    pt2d = (x_rand, y_rand)

    hit, pt3d = backproject2DPoint(pt2d, K, R, t, vertices, triangles)


    if hit:
        color = (0, 255, 0)
    else:
        color = (0, 0, 255)

    cv2.circle(img_test, center=(x_rand, y_rand), radius=15, color=color, thickness=-1)

img_rgb = cv2.cvtColor(img_test, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(12, 8))
plt.imshow(img_rgb)
plt.title("Inlier/outlier test")
plt.axis("off")
plt.show()

import pickle
def serialize_keypoints(keypoints):
    return [(
        kp.pt, kp.size, kp.angle, kp.response, kp.octave, kp.class_id
    ) for kp in keypoints]
def deserialize_keypoints(keypoints_data):
    return [cv2.KeyPoint(
        x=pt[0][0], y=pt[0][1],
        size=pt[1], angle=pt[2],
        response=pt[3],octave=pt[4], class_id=pt[5]
    ) for pt in keypoints_data]

import pickle
points_3d = result["points3d"]
keypoints = result["keypoints"]
descriptors = result["descriptors"]
points2d_in = result["points2d_in"]

result = {
    "keypoints": serialize_keypoints(model_keypoints),
    "descriptors": model_descriptors,
    "points2d_in": model_2dpoints_in,
    "points3d": model_3dpoints
}

with open("result.pkl", "wb") as f:
    pickle.dump(result, f)
